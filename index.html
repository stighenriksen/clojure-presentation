<!DOCTYPE html>
<html>
  <head>
    <title>Clojure-intro</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link href='http://fonts.googleapis.com/css?family=Yanone+Kaffeesatz:400,700,200' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Inconsolata' rel='stylesheet' type='text/css'>
    <script src="https://github.com/downloads/gnab/remark/remark-0.3.6.min.js" type="text/javascript">
      { "highlightStyle": "monokai", "highlightLanguage": "clojure", "highlightInline": true }
    </script>
    <script type="text/javascript">
      // Create hljs variable for clojure.js to extend
      var hljs = remark.highlighter.engine();

      // Simple timer
      var timerElement;
      remark.on('slidein', function (el, idx) {
        if (idx === 1) {
          if (timerElement === undefined) {
            timerElement = document.createElement('div');
            timerElement.className = 'position';
            timerElement.style.left = '20px';
            document.getElementById('slideshow').appendChild(timerElement);

            var start = Date.now();
            setInterval(function () {
              timerElement.innerHTML = Math.floor((Date.now() - start) / 60000) +
                ' min';
            }, 1000);
          }
        }
      });
    </script>
    <script src="clojure.js" type="text/javascript"></script>
    <style type="text/css" media="screen">
      .frontpage {
        background: url(images/clojure-icon.gif) no-repeat 50% 35%;
      }
      .blur {
        background: url(images/clojure-blur.png) no-repeat bottom right;
      }
      h1, h2 {
        font-family: 'Yanone Kaffeesatz';
        font-size: 3em;
        font-weight: 400;
      }
      h2 {
        font-size: 2em;
        margin: 0;
        margin-bottom: 10px;
      }
      pre code {
        -moz-border-radius: 15px;
        -web-border-radius: 15px;
        border-radius: 15px;
        padding: 15px 20px;
      }
      .clojure .title {
        color: #F92672;
        font-weight: bold;
      }
      #slideshow .slide .content code { font-family: 'Inconsololata', monospace; }
      .red {
        color: #F92672;
      }
      .left-col {
        float: left;
        width: 47%;
      }
      .right-col {
        float: right;
        width: 47%;
      }
      .left-col-40 {
        float: left;
        width: 37%;
      }
      .right-col-60 {
        float: right;
        width: 57%;
      }
      .footnote {
        position: absolute;
        bottom: 1.5em;
      }
      .adjust {
        padding-bottom: 31px;
      }
    </style>
  </head>
  <body>
    <textarea id="source">

.frontpage.center.middle
# (clojure-intro)

---

# Clojure er en LISP.red[*]-dialekt

Prefiks-notasjon i stedet for infiks-notasjon:

    + 1 * 2 3

Datastrukturer som kode i stedet for tekst:

    (+ 1 (* 2 3)) ; => 1 + 2 * 3 = 1 + 6 = 7

Funksjonskall er vanlige lister med funksjon og argumenter:

    (some-function arg1 arg2 (another-function arg3 arg4))

Clojure skiller seg ut med alternativ syntaks for datastrukturer:

    [1 2 3 4]

.footnote[.red[*] LISt Processing]

---

# Deklarering og kall av funksjoner

Enkel funksjon for å duplisere et tall:

    (defn double [x] (+ x x))

    (double 1) ; => 2

Og en annen funksjon for å multiplisere to tall:

    (defn multiply [x y] (* x y))

    (multiply 2 3) ; => 6

Og en tredje funksjon for å kombinere de to foregående:

    (defn multiply-and-double [x y]
      (double (multiply x y)))

    (multiply-and-double 2 3) ; => 12

---

# Kontrollflyt og iterasjon vha. funksjoner

Enkel funksjon som returnerer det største av to tall:

    (defn max [x y] 
      (if (> x y)
        x
        y))

    (max 1 2) ; => 2

Enkel funksjon som bruker rekursjon til å summere tall:

    (defn sum [nums]
      (if (= 0 (count nums))
        0
        (+ (first nums) (sum (rest nums)))))

    (sum 1 2 3) ; => 6

---

# Få, enkle og fleksible datastrukturer

Enkle datastrukturer som lister / vektorer og nøkkel-verdi-par gir stor fleksibilitet:

- Få datastrukturer å forholde seg til
- Enkle å bruke &mdash; syntaktisk støtte
- Kan representere de fleste data


    (def twitter-profile-data {
      :user "some-user"
      :tweets [
        {:text "another tweet" :time "2012.09.18 11:00"}
        {:text "some tweet" :time "2012.09.18 10:00"}
      ]
    })


Oppslag i nøkkel-verdi-par gjøres ved å kalle nøklene som funksjoner:

    (:time (first (:tweets twitter-profile-data)))

---

# Funksjonell programmering (1/2)

Funksjoner er på nivå med ordinære verdier, som kan brukes som argumenter:

    (defn double [x] (+ x x))

    (map double [0 1 2 3]) ; => [0 2 4 6]

&hellip; og som returverdi fra funksjoner:

    (defn make-multiplier [x]
      (fn [y] (* y x)))

    (def triple (make-multiplier 3))

    (map triple [0 1 2 3]) ;=> [0 3 6 9]

---

# Funksjonell programmering (2/2)

Standard sett med funksjoner for å behandle lister / vektorer og nøkkel-verdi-par:

    (first [1 2 3]) ; => 1
    (rest  [1 2 3]) ; => (2 3)
    (cons  1 [2 3]) ; => (1 2 3)


Ved hjelp av de tre funksjonene, er en rekke andre funksjoner implementert:

    (second [1 2 3])     ; => 2
    (nth [1 2 3] 2)      ; => 3

    (last [1 2 3])       ; => 3
    (concat [1 2] [3 4]) ; => (1 2 3 4)

    (map ...)
    (filter ...)
    (take ...)
    (partition ...)

---

# Eksempel

Klumpete Java-metode for å returnere alle små bokstaver fra streng:

    .java
    public static ArrayList<Character> getLower(String s) {
      ArrayList<Character> chars = new ArrayList<Character>();
      for (int i = 0; i < s.length(); i++) {
        char ch = s.charAt(i);
        if (Character.isLowerCase(ch)) {
            chars.add(ch);
        }
      }
      return chars;
    }

Med funksjonell programmering løses dette langt enklere:

    (defn get-lower [s]
      (filter #(Character/isLowerCase %) s))


---

# Makroer (1/2)

Uvanlig fleksibelt makrosystem - kode behandler kode som datastrukturer:

- Makroer er spesielle funksjoner som tar inn og returnerer datastrukturer
- Ved kall sendes argumenter inn uten å evalueres
- Makroens kode lager ny datastruktur som skal kjøres i dens sted


    (xml                        ; => "<xml>
      (book                     ;      <book>
        (authors                ;        <authors>
          (author "Luke")       ;          <author>Luke</author>
          (author "Stuart"))))  ;          ...

---

# Makroer (2/2)

.left-col-40[
Evaluering av funksjoner:

    (+ (+ 2 3) (* 4 5))

&nbsp;&nbsp;&nbsp;&nbsp;1\. `(+ 2 3)`


    (+ 5 (* 4 5))

&nbsp;&nbsp;&nbsp;&nbsp;2\. `(* 4 5)`

    (+ 5 20)

&nbsp;&nbsp;&nbsp;&nbsp;3\. `(+ 5 20)`

    (+ 5 20) ; => 25
]

.right-col-60[
Evaluering av makroer:

    (xml (book (author "Luke")))

&nbsp;&nbsp;&nbsp;&nbsp;1\. Makro ekspanderes og ny kode returneres:

    .adjust
    (defn xml-helper [form]
      (if (not (seq? form))
        (str form)
        (let [name (first form)
              children (rest form)]
          (str "<" name ">"
               (apply str
                 (map xml-helper children))
               "</" name ">"))))

    (defmacro xml [form]
      (xml-helper form))

]

---

# Clojure er implementert på JVMen.red[*]

Om man "oversetter" direkte fra Java kan man like gjerne bruke Java:

    (def numbers (new java.util.ArrayList)) ; => #<ArrayList []>
    (. numbers add 1)
    (. numbers add 2)
    (. numbers add 3)
    ; numbers => #<ArrayList [1, 2, 3]>

Men bruk av idiomatisk Clojure kan gi det beste fra begge verdener:

    (map (memfn toUpperCase) ["a" "short" "message"])
    ; => ("A" "SHORT" "MESSAGE")

.footnote[.red[*] En implementasjon finnes også til CLRen.]

---

.middle.blur
# Spørsmål?


    </textarea>
    <div id="slideshow"></div>
  </body>
</html>
